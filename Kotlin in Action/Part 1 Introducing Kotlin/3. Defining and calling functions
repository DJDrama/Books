[3. Defining and calling functions]
- Kotlin does not have its own set of collection classes.
	- using the standard Java collections amkes it much easier to interact with Java code.
- Kotlin uses the standard Java collection classes.
- We can do more with Kotlin collections.
	Ex) we can get the last element in a list or find a maximum in a collection of numbers.
		// list.last()
		// numbers.max()

- joinToString
	- function shown next appends the elements of the collection to a StringBuilder, with a separator between them, a prefix at the beginning, and a postfix at the end.

	- Function is generic: works on collections that contain elements of any type.

- Named arguments
	- specify the names of some arguments that you're passing to the function.

- Default parameter values
	- problem of Java : overabundance of overloaded methods in some classes
	- We can avoid creating overloads in Kotlin
		- can specify default values for parameters in a function declaration.
	* default values of the parameters are encoded in the function being called, not at the call site.
		- If you change the default value and recompile the class containing the function, the callers that haven't specified a value for the parameter will start using the new default value.

	- @JvmOverloads : when need to call a function from Java, this instructs the compiler to generate Java overloaded methods, omitting each of the parameters one by one, starting from the last one!


- Top-level functions
	- Place functions directly at the top level of a source file, outside of any class.

	Ex) Java code that would compile to the same class
	// join.kt 
	// fun joinToString(...): String { ... }
	===============================================
	// public class JoinKt {
	// public static String joinToString(...) { ... }
	// }
	//
	// JoinKt.joinToString(list, ", ", "", ""); // Java Style
		* name of the class generated by the Kotlin compiler corresponds to the name of the file containing the function.
		* All top-level functions in the file are compiled to static methods of that class. (Calling top-level functions from Java is as easy as calling any other static method)

	- @JvmName
		- Use it to change the name of the generated class that contains Kotlin top-level functions.
			Ex) @file:JvmName("StringFunctions")
				--> StringFunctions.joinToString(list, ", ", "", ""); // Java Style

- Top-level Properties
	- Properties can be placed at the top level of a file.
	- They are exposed to Java code as Accessor methods (getter for val, getter / setter for var)
	- put "const" to make "final" like Java
		- "const" modifier is only allowed for properties of primitive types, as well as String

		Ex) const val HELLO = "hello" --> public static final String HELLO = "hello"

- Extension Functions
	- Function that can be called as a member of a class but is defined outside of it.
	- Receiver Type, Receiver Object
		Ex) fun String.lastChar(): Char = this.get(this.length-1)
			// String: Receiver Type
			// this: Receiver Object
		* Receiver object members can be accessed without "this".

	- Extension functions need to be imported, just like any other class or function.
		-> helps avoid accidental name conflicts.

	- Can change a name on import
		Ex) import strings.lastChar as last
		// val c = "Kotlin".lastChar() --> val c = "Kotlin".last()

	- Extension function is a static method that accepts the receiver object as its first argument.
		Ex) Java
		// char c = StringUtilKt.lastChar("Java");

		* Extension function is declared as a top-level function, so it's compiled to static method.

- No overriding for extension functions
	- can't override an extension function.
	- Extension functions aren't a part of the class; they're declared externally to it.
	- the function that's called depends on the declared static type of the variable, not on the runtime type of the value stored in that variable.
	- Kotlin resolves extension functions statically.


- Extension properties
	- They can't have "state", because there's no proper place to store it.
		* not possible to add extra fields to existing instances of Java objects.
	- Extension property looks like a regular property with a receiver type added.
	- The getter must always be defined, because there's no backing field and therefore no default getter implementation.
		Ex) 
		// val String.lastChar: Char
			get() = get(length-1)
	- Initializers aren't allowed for the same reason: there's nowhere to store the value specified as the initializer.

- Varargs (vararg modifier)
	- can pass any number of arguments to it
		Ex) fun listOf<T>(vararg values: T): List<T> { ... }
		// val list = listOf(1, 2, 3, ...)

	- spread operator (put * character before the corresponding argument)
		Ex)
		// fun main(args: Array<String>){
		//		val list = listOf("args : ", *args)
		//		println(list)
		// }

- infix class
	Ex) 1 to "one" // to: infix call, also same as 1.to("one")

	- can be used with regular methods and extension functions that have one required parameter.
		Ex) infix fun Any.to(other: Any) = Pair(this, other)

		* there should be at least one required parameter.

- Destructuring declaration
	Ex) val (number, name) = 1 top "one"

- Local Functions
	- Use local functions for duplicate codes such as Validation
	

