3.2.3 Getting rid of static utility classes: top-level functions and properties
	- You don't need to create all those meaningless classes.
	- Instead, you can place functions directly at the top level of a source file, outside of any class.
	- Such functions are still members of the package declared at the top of the file, and you still need to import them if you want to call them from other packages, but the unnecessary exra level of nesting no longer exists.


	- Top level functions will become static functions inside a class in JAVA
		ex)	
			========================================================
			hello.kt

			fun hello(){ ... }

			--> To Java
			public class HelloKt {
				public static void hello(){ ... }
			}
			========================================================
			-> name of the class generated by the Kotlin compiler corresponds to the name of the file containing the function
				- capitalized to match Java's naming scheme, and suffixed with kt.

			-> All top-level functions in the file are compiled to static methods of that class

			* Therefore, calling this function from Java is as easy as calling any other static method:
				ex)
					========================================================
					import HelloKt;

					HelloKt.hello()
					========================================================

			* By default, the class name generated by the compiler corresponds to the file name, together with a "Kt" suffix.

			* to change the name of the generated class that contains Kotlin top-level functions, you add a @JvmName annotation to the file.
				ex)
					========================================================
					@file:JvmName("Hello")

					fun hello(){...}

					-->
					import Hello;
					Hello.hello();
					========================================================

	- Top-level properties
		* properties can be also placed at the top level of a file.

			ex)
				========================================================
				var hello = "Hello"
				fun printHello(){
					println(hello)
				}
				========================================================
				-> By default, top-level properties, just like any other properties, are exposed to JAva code as acessor methods (a getter for a val property and a getter/setter pair for a var property)
				-> The value of such a property will be stored in a static field.

		* To make static final field, mark it as "const"
			ex)
				========================================================
				const val HELLO = "Hello"
				========================================================
