(Chapter 6 - The Secret Life of Objects)

	[Encapsulation]
		- Object-Oriented programming
			-> is to divide programs into smaller pieces and make each piece responsible for managing its own state.

			-> someone working on the rest of the program does not have to remember or even be aware of that knowledge.(some knowledge about the way a piece of the program works can be kept "local" to that piece.)

			-> different pieces of such a program interact with each other through "interfaces", limited sets of functions or bindings that provide useful functionality at a more abstract level.
				+ hiding their precise implementation.

		- common to put an underscore(_) characer at the start of property names to indicate that those properties are private.

		- "encapsulation"
			-> separating interface from implementation is a great idea.

	[Prototypes]
		- most objects have a "prototype".
			-> A prototype is another object that is used as a fallback source of properties.

		- "Object.getPrototypeOf" returns the prototype of an object.

		- Functions derive from "Function.prototype", and arrays derive from "Array.prototype".
			ex)
				==================================================
				console.log(Object.getPrototypeOf(Math.max)
					== Function.prototype);
				// true

				console.log(Object.getPrototypeOf([])
					== Array.prototype);
				// true
				==================================================

		- can use "Object.create" to create an object with a specific prototype.
			ex)
				==================================================================
				let protoRabbit = {
					speak(line) {
						console.log(`The ${this.type} rabbit says '${line}'`)
					}
				};

				let killerRabbit = Object.create(protoRabbit);
				killerRabbit.type = "killer";
				killerRabbit.speak("SKREEEE!");
				// The killer rabbit says 'SKREEEE!'
				==================================================================

	[Classes]
		- defines the shape of a type of object - what methods and properties it has.
			-> Such an object is called an "instance" of the class.

		- constructor
			ex)
				==================================================================
				function makeRabbit(type) {
					let rabbit = Object.create(protoRabbit);
					rabbit.type = type;
					return rabbit;
				}
				==================================================================

		- put the keyword "new" in front of a function call, the function is treated as a constructor.
			ex)
				==================================================================
				function Rabbit(type){
					this.type = type;
				}

				Rabbit.prototype.speak = function(line) {
					console.log(`The ${this.type} rabbit says '${line}'`);
				}

				let weirdRabbit = new Rabbit("weird");
				==================================================================

		- Constructors (all functions, in fact) automatically get a property named prototype, which by default holds a plain, empty object that derives from "Object.prototype".

		* By convention, the names of constructors are capitalized so that they can easily be distinguished from other functions.

		- The actual prototype of a constructor is "Function.prototype" since constructors are functions.
			ex)
				==================================================================
				console.log(Object.getPrototypeOf(Rabbit) == Function.prototype);
				// true

				console.log(Object.getPrototypeOf(weirdRabbit) == Rabbit.prototype);
				// true
				==================================================================
				
	[Class Notation]
		- "class" keyword starts a class declaration.
			ex)
				==================================================================
				class Rabbit {
					constructor(type) {
						this.type = type;
					}

					speak(line) {
						console.log(`The ${this.type} rabbit says '${line}'`);
					}
				}
				let killerRabbit = new Rabbit("killer");
				let blackRabbit = new Rabbit("black");
				==================================================================
				+ "class" allows us to define a constructor and a set of methods all in a single place.

	[Maps]
		- "map" is a data structure that associates values (the keys) with other values.
			ex)
				==================================================================
				let ages = {
					Boris: 39,
					Liang: 22,
					Julia: 62
				}
				==================================================================

		- JavasScript comes with a class called "Map"
			ex)
				==================================================================
				let ages = new Map();
				ages.set("Boris", 39);
				ages.set("Liang", 22);
				ages.set("Julia", 62);

				console.log(`Julia is ${ages.get("Julia")}`);
				// Julia is 62
				console.log("Is Jack's age known?", ages.has("Jack"));
				// Is Jack's age known? false
				console.log(ages,has("toString"));
				// false
				==================================================================

	[Symbols]
		- values created with the "Symbol" function.
			-> Unlike strings, newly created symbols are unique - you cannot create the same symbol twice.

			ex)
				==================================================================
				let sym = Symbol("name");
				console.log(sym == Symbol("name"));
				// false

				Rabbit.prototype[sym] = 55;
				console.log(blackRabbit[sym]);
				// 55

				const toStringSymbol = Symbol("toString");
				Array.prototype[toStringSymbol] = function() {
					return `${this.length} cm of blue yarn`;
				}

				console.log([1, 2].toString());
				// 1, 2

				console.log([1, 2][toStringSymbol]());
				// 2 cm of blue yarn
				==================================================================

		- it is possible to include symbol properties in object expressions and classes by using square brackets around the property name.
			ex)
				==================================================================
				let stringObject = {
					[toStringSymbol]() { return "a jute rope";}
				};

				console.log(stringObject[toStringSymbol]());
				// a jute rope
				==================================================================

	[The Iterator Interface]
		- object tiven to a "for/of" loop is expected to be "iterable".
			-> it has a method named with the "Symbol.iterator" symbol.

	[Getters, Setters, and Statics]
		- "Map" objects have a "size" property that tells you how many keys are stored in them.

		- Properties that are accessed directly may hide a method call.
			ex) getter
				==================================================================
				let varyingSize = {
					get size() {
						return Math.floor(Math.random() * 100);
					}
				}

				console.log(varyingSize.size);
				// 73

				console.log(varyingSize.size);
				// 49
				==================================================================

			ex) setter
				==================================================================
				class Temperature {
					constructor(celsius) {
						this.celsius = celsius;
					}

					get fahrenheight() {
						return this.celsius * 1.8 + 32;
					}

					set fahrenheight(value) {
						this.celsius = (value - 32) / 1.8;
					}

					// factory method
					static fromFarenheit(value) {
						return new Temperature((value - 32) / 1.8);
					}
				}

				let temp = new Temperature(22);
				console.log(temp.fahrenheight); // 71.6
				
				temp.fahrenheight = 86;
				console.log(temp.fahrenheight); // 30
				==================================================================

	[Inheritance]
		- "extends", "superclass", "subclass"

	[The instanceof operator]
		- useful to know whether an object was derived from a specific class.
			ex)
				==================================================================
				console.log([1] instance of Array);
				// true
				==================================================================

		* Almost every object is an instance of "Object".



