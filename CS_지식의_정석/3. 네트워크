[네트워크]
	1. 네트워크, 처리량, 트래픽, 대역폭, RTT
		- 네트워크
			- 노드(node)와 링크(link)가 서로 연결되어 있으며 리소스를 공유하는 집합을 의미.
				- 노드 : 서버, 라우터, 스위치 등 네트워크 장치
				- 링크(엣지) : 유선 또는 무선과 같은 연결매체 (와이파이나 LAN)

		- 트래픽
			- 특정 시점에 링크 내의 '흐르는' 데이터의 양
				- 예) 서버에 저장된 파일(문서, 이미지, 동영상 등)을 클라이언트가 다운로드시 발생되는 데이터의 누적량을 의미.
			
			- 트래픽이 많다 : 흐르는 데이터가 많아지는 경우
			- 처리량이 많다 : 처리되는 트래픽이 많아지는 경우

				- 예) 트래픽 발생 : 단위 : bps (bits per second)
				- 100kb 이미지를 1,000명이 다운로드 시 누적 트래픽은? 100kb * 1,000 = 100,000kb(100MB)
				- 10MB 동영상을 10명이 다운로드시 누적 트래픽은? 10MB * 10 = 100MB

		- 처리량(throughput)
			- 링크 내에서 성공적으로 전달된 데이터의 양을 말하며 보통 얼만큼의 트래픽을 처리했는지를 나타냅니다.
				- 많은 처리량을 가진다 : 많은 트래픽을 처리한다.
				- 단위 : bps(bits per second) 초당 전송 또는 수신되는 비트 수
			- 처리량은 사용자들이 많이 접속할 때마다 커지는 트래픽, 네트워크 장치 간의 대역폭, 네트워크 중간에 발생하는 에러, 장치의 하드웨어 스펙에 영향을 받음.

		- 대역폭(bandwidth)
			- 주어진 시간 동안 네트워크 연결을 통해 흐를 수 있는 최대 비트 수를 말함.
				- 대역폭이 높을수록 사용자에게 빠른 서비스를 제공.
				- 대략적인 최대 동시 접속자수 유추의 척도가 된다.
				- 단위 : bps(bits per second) 초당 전송 또는 수신되는 비트 수

				- 100Mbps라는 대역폭을 가진 서버가 있고, 한 사용자당 100kbps로 동영상 파일을 요청할 시 최대 동접자 수는?
					--> 100,000 / 100 = 약 1,000명
		- RTT (Round Trip Time)
			- 신호를 전송하고 해당 신호의 수신확인에 걸린 시간을 더한 값이자 어떤 메시지가 두 장치 사이를 왕복하는 데 걸린 시간.
				예) 800ms 전송, 900ms 수신 --> RTT = 1700ms(1.7s)

	2. 네트워크 토폴로지 : 버스, 스타, 트리
		- 네트워크 토폴로지 : 노드와 링크가 어떻게 구성 되어 있는지를 뜻함.
		- 버스 토폴로지
			- 특징
				1. 하나의 회선에 여러개의 노드
				2. 노드 추가, 삭제 쉬움
				3. 설치 비용 적음
			- 장점
				1. 소규모 네트워크를 구축하기 쉬움
				2. 한 노드에 장애가 발생해도 다른 노드에 영향 미치지 않음.
			- 단점
				1. 메인 링크에 많은 트래픽이 생기면 정체현상 발생 가능성 높음 (패킷 손실율 높음)
				2. 메인 링크 망가지면 큰 문제
		- 스타 토폴로지
			- 특징
				1. 중앙에 있는 노드를 기반으로 연결된 형태
				2. 노드 추가, 삭제 쉬움
			- 장점
				1. 중앙노드가 아닌 한 노드에 장애가 발생해도 다른 노드에 영향을 미치지 않음.
				2. 안정성이 높음. 중앙노드가 아닌 한 노드에 침해가 발생했을 때 다른 노드로 확장하기 어려움.(다른 노드로 가려면 중앙노드를 무조건 거처야 하므로)
				3. 한 링크에 문제가 생겨도 해당 부분만 영향을 받고 나머지는 정상 작동.
			- 단점
				1. 중앙 노드 에러시 큰 문제.
		- 트리 토폴로지
			- 특징
				1. 트리형태(계층적 토폴로지)
				2. 노드 추가, 삭제 보통(리프 노드를 기반으로 확장은 용이, 그러나 다른 노드는 어려움)
				3. 버스 토폴로지와 스타토폴로지의 하이브리드 형태
			- 장점
				1. 노드 확장이 용이(주로 리프노드로 확장함)
				2. 리프 노드의 에러는 나머지 부분에 영향을 미치지 않음.
			- 단점
				1. 특정 노드 트래픽 집중시 하위노드에 영향.
				2. 루트노드에 문제가 생기면 전체 네트워크에 큰 문제.
			- 백본케이블 : 여러 소형 네트워크들을 묶어 대규모 파이프라인을 통해 극도로 높은 대역폭으로 다른 네트워크들의 집합과 연결되는 네트워크(대규모 패킷 통신망)

	3. 네트워크 토폴로지: 링, 메시
		- 링형 토폴로지
			- 특징
				1. 고리 형태
				2. 노드 추가, 삭제가 쉬움.
			- 장점
				1. 노드 수가 많아져도 데이터 손실 없음. 토큰을 기반으로 연속적으로 노드를 거치며 통신 권한 여부를 따지고 해당 권한이 없는 노드는 데이터를 전달받지 않음.
			- 단점
				1. 링크 또는 노드가 하나만 에러 발생해도 전체 네트워크에 영향
				2. 토큰이 없는 노드는 통신에 참여를 못하며 데이터 공유가 안됨.

		- 메시 토폴로지
			- 특징
				1. 그물망 형태
				2. 노드 추가, 삭제 어려움
				3. 풀 메시 토폴로지의 경우 n * (n-1) / 2 의 회선이 필요함.
			- 장점
				1. 안정성이 높음. 한 노드가 장애가 나도 다른 노드에 영향을 미치지 않음.
				2. 트래픽 분산 가능
			- 단점
				1. 회선이 비효율적으로 많기에 구축 비용이 고가.

	4. 네트워크 토폴로지의 필요성과 병목현상
		- 토폴로지의 필요성 : 병목현상을 해결하는 척도가 된다.

		- 병목현상 : bottleneck - 트래픽에 의해 데이터 흐름이 제한되는 상황 (핫스팟이라고도 부름 (네트워크 한정))
			--> 해결 : Distributed Web Infrastructure

	5. 유니캐스트, 멀티캐스트, 브로드캐스트
		- 유니캐스트
			- 1:1 통신 / HTTP
			- 가장 일반적인 네트워크 전송 형태
		- 멀티캐스트
			- 1: 그룹 통신 / 방송
			- 그룹에 속한 장치들에게 데이터 전달.
		- 브로드캐스트
			- 1: 모든 통신 / ARP (Address Resolution Protocol)
			- 로컬 네트워크 내에 있는 모든 호스트에게 데이터를 전달할 

		- 네트워크의 분류 : LAN, MAN, WAN
			1. LAN (Local Area Network - 근거리 통신망)
				- MAN, WAN 보다 높은 안정성, 속도 / 소규모 네트워크(집, 사무실) - 보통 허브나 스위치로 연결됨.
				- 하나의 논리적 주소인 IP를 기반으로 여러개의 물리적 주소인 MAC 주소로 구별하는 네트워크라고도 볼 수 있음.
			2. MAN (Metropolitan Area Network - 대도시 통신망)
				- 도시와 도시의 통신망을 뜻하며 2개 이상의 LAN이 연결되어 구성됨
				- 라우터, 브릿지 등으로 연결됨
			3. WAN (Wide Area Network - 광역 통신망)
				- 국가와 국가간의 통신망을 뜻하며 인터넷이라고도 함.
				- 많은 라우터를 거쳐 다른 국가와도 연결됨.

		- TCP / IP 4계층
			- 장치들이 인터넷 상에서 데이터를 주고받을 때 쓰는 독립적인 프로토콜의 집합을 의미
			- TCP / IP : Transmission Control Protocol / Internet Protocol
				- 인터넷을 통해 데이터를 보낼 때 주로 TCP와 IP를 이용해서 보내기 때문
			
			[Application - SMTP, HTTP/HTTPS, FTP, SSH]
			[Transport - UDP, TCP]
			[Internet - IPv4 / IPv6, ICMP, ARP]
			[Network Access (네트워크 접속 계층 - 링크 계층)]

			1. Application 계층
				- HTTP, SMTP, SSH, FTP 등 웹 서비스, 이메일 등 서비스를 실질적으로 사람들에게 제공하는 층.
			2. Transport 계층 (전송 계층)
				- TCP, UDP가 대표적
				- 어플리케이션 계층에서 받은 메세지를 기반으로 세그먼트 또는 데이터그램으로 데이터를 쪼개고 데이터가 오류없이 순서대로 전달되도록 도움을 주는 층.
			3. Internet (인터넷 계층)
				- IP, ICMP, ARP가 대표적이며 한 노드에서 다른 노드로 전송 계층에서 받은 세그먼트 또는 데이터그램을 패킷화 하여 목적지로 전송하는 역할을 담당.
			4. Network Access (Link 계층)
				- 전선, 광섬유, 무선 등으로 데이터가 네트워크를 통해 물리적으로 전송되는 방식을 정의.

		- 캡슐화와 비캡슐화
			- Encapsulation(캡슐화)
				- 송신자가 수신자에게 데이터를 보낼 때 데이터가 각 계층을 지나며 각 계층의 특징들이 담긴 헤더들이 붙여지는 과정.
					- 예) 전송계층은 TCP 헤더, 네트워크 계층은 IP 주소 헤더를 추가
			- Decapsulation(비캡슐화)
				- 캡슐화 과정의 역과정.
				- 수신자 측에서 캡슐화된 데이터를 역순으로 제거하면서 운용계층까지 도달하는 것을 의미.
		
		- PDU(Protocol Data Unit)
			- TCP / IP 4계층을 기반으로 각 계층의 데이터 단위를 의미
				1. 애플리케이션 계층 : 메시지
				2. 전송 계층 : 세그먼트(TCP), 데이터그램(UDP)
				3. 인터넷 계층 : 패킷
				4. 링크 계층 : 프레임(데이터 링크 계층), 비트(물리 계층)
			- 세그먼트 : 적절한 크기로 쪼갠 조각 (세그먼트와 데이터그램의 의미는 같음)
			- 패킷 : 세그먼트에 SP와 DP가 포함된 IP헤더가 붙은 형태의 조각
				- SP: 송신자의 32비트 IP주소
				- DP: 수신자의 32비트 IP주소
					- IPv4 기준.
			- 프레임 : MAC주소 헤더와 CRC / 체크섬 트레일러가 붙은 조각.
				- CRC / 체크섬 트레일러
					- 데이터의 오류감지를 위한 수학적 함수가 적용된 값.
					- 링크의 오류(과도한 트래픽) 로 인해 데이터 손상을 감지하는 역할을 함.

		- OSI 7계층
			- TCP / IP 계층과 달리 OSI 계층은 애플리케이션 계층을 세 개로 쪼개고 링크 계층을 데이터 렝크 계층, 물리 계층으로 나눠서 표현
			- 인터넷 계층을 네트워크 계층으로 부름.

			(Application Layer)
			[Application Layer]
			[Presentation Layer]
			[Session Layer]

			(Transport Layer)
			[Transport Layer]

			(Internet Layer)
			[Network Layer]

			(Network Access Layer)
			[Data-Link Layer]
			[Physical Layer]

		- 패킷으로 쪼개질 때 MTU(Maximum Transmission Unit)를 기반으로 쪼개짐.
		- MTU는 네트워크 통신 시 가장 큰 PDU의 크기를 말함.

		- MTU와 MSS
			- MTU는 IP헤더와 TCP 헤더의 크기까지 합치지만 MSS(Maximum Segment Size)는 TCP에서 사용할 수 있는 데이터의 크기이자 TCP 헤더, IP 헤더를 뺀 크기를 말함.
			- MTU : IP header + TCP header
			- MSS : No Ip Header, No TCP Header
			- 일반적으로 MTU는 1500바이트, MSS는 1460 바이트(Payload) (IP 헤더 20byte, TCP 헤더 20byte)
				- MTU가 1500이라도 데이터는 보통 1460 바이트 이하의 크기로 보내야 전달이 가능하다.

		- 패킷이 분할되지 않는 경우
			- 패킷을 분할 할 수 없어 네트워크 경로 상에 있는 어떠한 라우터나 장치의 MTU를 초과할 때 분할해서 전달하는 것이 아니라 전달을 아예 하지 않을 수도 있음.

			- IPv6 : 분할을 허용하지 않음.
			- IPv4 : Flags 필드가 존재하며 bit가 1이되면 "Don't Fragment" (DF) 플래그가 활성화되어 분할이 불가능해짐.

		- PMTUD(Path MTU Discovery)
			- 수신자와 송신자의 경로 상에서 장ㅇ치가 패킷을 누락한 경우 테스트 패킷의 크기를 낮추면서 MTU에 맞게끔 반복해서 보내는 과정을 말함.

		- HTTP
			- Hypertext Transfer Protocol
				- 서버와 브라우저간에 데이터를 주고 받기 위해 설계된 프로토콜.
				- 브라우저 뿐만 아니라 서버와 서버간의 통신할 때도 많이 이용.
				- 특징
					1. HTTP는 헤더를 통한 확장이 쉬움
						- 헤더 값에 어떠한 값을 넣어서 HTTP 요청을 할 때 쉽게 다른 값을 추가할 수 있음.
					2. HTTP는 stateless함.
						- 동일한 연결에서 연속적으로 수행되는 두 요청 사이에 연속적인 상태(state)값은 없음.
						- 서버가 클라이언트의 이전 상태를 보존하지 않는다는 의미.
						- 만약 로그인 상태를 보존해야 한다면 stateless로 짜면 매번 로그인 해야함.
		- SSH
			- Secure Shell Protocol
			- 보안되지 않은 네트워크에서 네트워크 서비스를 안전하게 운영하기 위한 암호화 네트워크 프로토콜.
			- 보통 프라이빗 키가 있는 경로에서 키를 명시하고 실행
				- ssh <pem> <user>@<serverIP>
			- SCP(Secure Copy)를 이용해서 SSH를 이용해 파일을 전송할 수 있음.
				- scp <source> <destination>

		- FTP
			- 노드와 노드간의 파일을 전송하는데 사용되는 프로토콜
			- 파일을 암호화해서 전송하는 FTPS, SFTP로 대체됨.

		- SMTP
			- 인터넷을 통해 메일을 보낼 때 사용되는 프로토콜(Simple Mail Transfer Protocol)
			- 보통 서비스를 운영하면 메일링 서비스를 하게 되는데 node.js를 통해 메일을 보낸다면 이를 통해 보내야 함.

		- TCP와 UDP
			- 애플리케이션 계층에서 받은 메시지를 기반으로 세그먼트 또는 데이터그램으로 데이터를 쪼개고 데이터가 오류없이 순서대로 전달되도록 도움을 주는 층.
			- TCP
				- 가상회선 패킷 교환 방식
				- 오류검사 메커니즘
					1. 재전송 : 시간 초과 기간이 지나면 서버는 전달되지 않은 데이터에 대해 재전송을 시도
					2. 체크섬 : 체크섬을 통해 무결성을 평가
						- 송신된 데이터의 체크섬과 수신된 데이터의 체크섬 값을 비교해서 올바르게 왔는지를 확인.
				- 해더
			- UDP
				- 데이터그램 패킷 교환 방식
				- 오류검사 메커니즘
					- 단순한 체크섬만 지원
				- 헤더
					- 32비트(8바이트) 고정길이

			- TCP vs UDP
				- TCP : 가상회선 패킷 교환 방식, UDP : 데이터그램 교환 방식
				- TCP : 신뢰성 O, UDP : 신뢰성 X
				- TCP : 재전송, 체크섬을 통한 오류검사, UDP : 체크섬만을 통한 오류검사
				- TCP : 패킷 순서 보장, UDP : 순서 보장하지 않음.
				- TCP : (20-60) 바이트 가변 헤더 길이, UDP : 8바이트 고정 헤더 길이
				- TCP : 연결보장함(3-way handshake로 연결을 맺고, 4-way handshake로 연결을 해제), UDP : 비연결성, 그냥 데이터를 보냄, 연결 해제 비용이 없음
				- TCP : 브로드캐스트 지원 X, UDP : 브로드캐스트 지원 O
				- TCP : 속도 느림, UDP : 속도 빠름.

			- 인터넷 계층(Internet Layer)
				- IP, ICMP, ARP가 대표적
				- 한 노드에서 다른 노드로 전송 계층에서 받은 세그먼트 또는 데이터그램을 패킷화 하여 전송

			- ICMP
				- ICMP(Internet Control Message Protocol)
				- 노드와 노드 사이에서 통신이 잘되는 지를 확인할 때 쓰는 프로토콜
				- 데이터를 교환하는데 사용되지 않는 프로토콜.
				- 일반적으로 echo request, echo request --> 테스팅에 사용됨.
				- IP와는 달리 TCP 또는 UDP와 같은 전송 계층 프로토콜과 연관되지 않고 독립적인 비연결형 프로토콜로, ICMP를 비연결형 프로토콜을 기반으로 구축됨.
					- 예) ping www.google.com 을 통해 ICMP로 하는 것을 확인할 수 있음.

			- TCP의 연결 성립 과정 : 3-way handshake
				1. SYN 단계 : 클라이언트는 서버에 클라이언트의 ISN(Initial Sequence Numbers)을 담아 SYN을 보냄.
				2. SYN + ACK 단계 : 서버는 클라이언트의 SYN을 수신, 서버의 ISN을 보내며 승인 번호로 클라이언트의 ISN + 1을 보냄.
				3. ACK 단계 : 클라이언트는 서버의 ISN + 1한 값인 승인번호를 담아 ACK를 서버에 보냄.

				* ISN: TCP(Transmission Control Protocol) 기반 데이터 통신에서 각각의 새 연결에 할당된 고유한 32비트 시퀀스 번호를 나타냄.
					- TCP 연결을 통해 전송되는 다른 데이터 바이트와 충돌하지 않는 시퀀스 번호를 할당하는 데 도움이 됨.
				* SYN: synchronization의 약자, 연결 요청 플래그
				* ACK: acknowledgement의 약자, 응답 플래그

			- TCP의 연결 해제 과정 : 4-way handshake
				1. 클라이언트가 연결을 닫으려고 할 때 FIN으로 설정된 세그먼트를 보냄. 클라이언트는 FIN_WAIT_1 상태로 들어가고 서버의 응답을 기다림.
				2. 서버는 클라이언트로 ACK라는 승인 세그먼트를 보내고 CLOSE_WAIT 상태에 들어감. 클라이언트가 세그먼트를 받으면 FIN_WAIT_2 상태에 들어감.
				3. 서버는 LAST_ACK 상태가 되며 일정 시간 이후에 클라이언트에 FIN이라는 세그먼트를 보냄
				4. 클라이언트는 TIME_WAIT 상태가 되고 다시 서버로 ACK를 보내서 서버는 CLOSED 상태가 되며, 이후 클라이언트는 어느 정도의 시간(TIME_WAIT으로 설정된 시간)을 대기한 후 연결이 닫힘.
					- TIME_WAIT : 지연 패킷이 발생했을 때 데이터 무결성을 해결하기 위함.
						- 두배의 최대 세그먼트 수명(MSL) 시간을 기다림.
							- MSL은 기본적으로 2분.
						- 소켓이 바로 소멸되지 않고 일정 시간 유지되는 상태를 말하며 지연 패킷 등의 문제점을 해결하는 데 쓰임.
						- 또한 연결을 올바르게 닫힌 상태로 만들기 위해 존재.
							- 예) CLOSED가 아닌 LAST_ACK로 되어 있으면 그 다음 연결 시 오류 발생.

			- 라우팅
				- 네트워크에서 데이터(패킷)를 보낼 때 최적의 경로를 선택하는 과정
				- 라우터가 위를 수행함.
				- 데이터는 보통 출발지에서 목적지로 가는 동안 여러개의 라우터를 거침
				- 여러번의 라우팅을 수행.(보통 초당 수백만번 일어남)
			- 라우터
				- 네트워크 사이에서 데이터를 전달하는 장치
				- 보통 둘 이상의 서로 다른 네트워크에 연결
				- 데이터(패킷)를 목적지로 보낼 때 최적의 경로를 결정, 해당 경로로 데이터를 넘겨주는 일 수행
				- 라우팅 테이블을 기반으로 데이터를 다음 목적지에 전달.
			- 라우팅 테이블
				- IP 주소를 기반으로 라우터의 위치를 저장한 테이블 또는 데이터베이스.
				- 다양한 네트워크에 대한 정보와 해당 네트워크에 연결하는 방법이 포함되어 있음.
				- 구성요소
					1. 네트워크 대상(Network Destination) : 목적지 네트워크의 IP 주소.
					2. 서브넷 마스크(Netmask) : 대상 주소를 설명할 때 쓰이는 값.
					3. 게이트웨이(Gateway): 장치와 연결되어 있는 홉, 패킷이 전달되는 다음 IP 주소(외부 네트워크와 연결된 장치)
						- 만약 목적지가 로컬 네트워크라면 '연결됨'라고 표기
						- 다른 네트워크라면 해당 네트워크의 게이트웨이를 가리킴.
					4. 인터페이스(interface) : 게이트웨이로 가기위해 거치는 장치
					5. 매트릭(Metric) : 우선순위라고도 불리며 패킷 전송을 위해 최적의 경로가 선택되도록 참고되는 값.
						* 동일한 라우팅테이블 요소가 2개 있을 때 값이 낮은 요소가 선택됨.
						* 일반적으로 홉 수가 들어가며 지연시간, 처리량 등이 들어갈 수 있음.
			- 게이트웨이
				- 프로토콜 변환기
				- 네트워크와 네트워크를 잇는 장치
				- 라우터와 하는 기능자체가 비슷
			- 홉(HOP)
				- 네트워크에서 출발지와 목적지 사이에 위치한 장치를 의미.
				- 홉 카운트 (Hop Count) : 데이터가 출발지와 목적지 사이에서 통과해야 하는 홉의 개수 의미.
				* 라우팅을 홉바이홉 통신이라고도 함.

			- IP 주소(Internet Protocl Address)
				- 논리적 주소
				- 컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기 위해 사용하는 특수 번호
				- IP를 기반으로 통신한다고도 하지만, 사실상 그 밑에 물리적 주소인 MAC 주소를 통해 통신.

			- MAC 주소 (Media Access Control Address)
				- 네트워크 인터페이스에 할당된 고유 식별자, 보통 장치의 NIC에 할당됨.
				- 48비트로 이루어져 있으며 24비트의 OUI와 24비트의 UAA로 이루어짐.
					- OUI : IEEE에서 할당한 제조사 코드
					- UAA: 제조사에서 구별되는 코드
			- IEEE (Institute of Electrical and Electronics Engineers)
				- 전기 / 전자 / 전산 분야의 국제 기구 및 학회.

			- PC의 NIC
			- ARP와 RARP (Address Resolution Protocol, Reverse)
				- MAC 주소는 ARP를 통해 파악 가능
				- ARP를 통해 논리적 주소인 IP 주소를 물리적 주소인 MAC 주소로 변환함.
				- 반대로 RARP를 통해 물리적 주소인 MAC 주소를 논리적 주소인 IP 주소로 변환.
			- ARP의 과정
				1. 해당 IP 주소에 맞는 MAC 주소를 찾기 위해 해당 데이터를 '브로드캐스팅'을 통해 연결된 네트워크에 있는 장치한테 모두 보냄.
				2. 맞는 장치가 있으면 해당 장치는 보낸 장치에게 유니캐스트로 데이터를 전달해 주소를 찾음.

			- IP 주소체계(이진수 이해하기)
				- 123 = 3*10^0 + 2*10^1 + 1*10^2
				- 2진수
					- 오른쪽 끝에서부터 각각의 자리는 1부터 2가 곱해지며, 1, 2, 4, 8, 16, 32 ... 2배씩 증가하게 되며 수를 표현.
					- 각각의 자리는 비트라고 할 수 있으며 0 or 1로 표현.

			- IPv4
				- 32비트
				- 2^32개의 주소(약 41억 9천만) 표현
				- 8비트 단위로 점을 찍어 4개로 구분(8비트 단위: 옥탯)
				- NAT, 서브네팅 여러개의 부수적인 기술이 필요.
					예) 172.16.254.1
						--> 10101100.00010000.11111110.00000001 (각 8비트, 총 32비트(4바이트))
			- IPv6
				- 128비트
				- 2^128개의 주소 표현(많은 주소 처리 가능)
				- NAT, 서브네팅 필요 없음.
				- 16비트씩 8개로 구분
				- 16비트는 16진수로 변환되어 콜론(:)으로 구분하여 표시(앞 연속되는 0은 생략 가능)
				- 앞 64비트 : 네트워크, 뒤 64비트: 인터페이스 주소
				* IPSec 내장되어 있음(데이터 패킷을 암호화 하는 보안 네트워크 프로토콜 제품군)
				* IPv4 헤더의 불필요한 필드를 제거하여 빠른 처리 가능.

			- IPv4는 체크섬이 있지만 IPv6는 없다.
				- IPv6는 헤더의 효율화를 위해 CRC(순환중복검사)를 제외
				- 다만 상위 프로토콜 TCP, UDP에서 이미 체크섬이 있기에 제거 가능.
				- UDP를 사용할 때 체크섬 필드는 선택사항이지만 UDP+IPv6로 사용할 경우 반드시 체크섬 필드 사용해야 함.
				- IPv4는 헤더가 가변길이이지만, IPv6는 고정길이(40바이트)라서 '인터넷 헤더길이'에 대한 정보가 삭제되었음. (이외에도 여러가지 불필요한 정보 삭제됨)

			- CRC (Cyclic Redundancy Check)
				- 순환 중복 검사
				- 네트워크상에서 데이터에 오류가 있는지 확인하기 위한 체크값을 결정하는 방식.
					1. 데이터 전송 전, 데이터의 값에 따라 CRC 값을 계산하여 데이터에 붙여 전송하고,
					2. 데이터 전송이 끝난 후 받은 데이터의 값으로 다시 CRC 값을 계산.
					3. 두 값을 비교하고, 값이 다르면 전송 과정에서 잡음 등에 의해 오류가 덧붙여 전송된 것임을 알 수 있음.

			- TTL(Time to live)
				- IPv4에서 TTL 필드는 패킷이 네트워크에서 무한 순환하지 않도록 하는 변수.
				- 패킷이 네트워크에서 라우터를 거칠 때마다 TTL 값이 1씩 감소.
				- 값이 0이 되면 폐기됨
				* HOP limit으로 대체됨.

			- IPv4와 IPv6 어떤게 좋은가? 더 빠른가?
				1. IPv6는 IPv4보다 많은 주소를 표현할 수 있음.
				2. IPv6는 불필요한 헤더가 삭제되어서 빠름.
				3. IPV6는 기본적으로 IPSec(네트워크 보안제품군)이 포함되어서 보안적인 측면에서도 좋음.

			- Classful IP Addressing
				- IP주소는 인터넷 주소로 네트워크 주소, 호스트주소 두 부분으로 나뉨.
					- 네트워크 주소 : 호스트들을 모은 네트워크를 지칭
					- 네트워크주소가 동일 = 로컬 네트워크
					- 호스트주소 : 호스트를 구분하기 위한 주소
						- 네트워크 호스트는 컴퓨터 네트워크에 연결된 컴퓨터나 기타 장치.
				- 정의
					- 네트워크 주소를 매기고 그에 따라 네트워크의 크기를 다르게 구분하여 클래스를 할당하는 주소체계
					- 구분하는 기준자(첫, 2, 3옥탯)을 서브넷 마스크라고 함.

			- ClassLess
				- classful의 단점을 해결하기 위해 클래스리스가 나옴.
				- 클래스로 나누는 것이 아닌 서브넷 마스크를 중심으로 어디까지가 네트워크 주소고 어디까지가 호스트주소인지를 나눔.
					* 서브네팅: 네트워크를 나눈다는 의미
					* 서브넷 : 서브네트워크 (쪼개진 네트워크)
					* 서브넷 마스크 : 서브네트워크를 위한 비트마스크
			- 서브넷마스크
				- 네트워크주소 부분만 모두1, 호스트주소 부분은 0으로 설정
			- IP주소는 공인(public IP)와 시설(Private IP)로 나누어짐.
			- 중간에 NAT라는 기술을 통해 해결
				- Network Address Translation
					- 패킷이 트래픽 라우팅 장치를 통해 전송되는 동안 패킷의 IP주소를 변경, IP 주소를 다른 IP 주소로 매핑하는 방법.
				- NAT를 통해 내부 네트워크의 IP가 노출되지 않는다는 점이 장점
			- 공유기와 NAT
				- 인터넷 회선 하나를 개통하고 보통 공유기를 써서 wifi를 만들곤 하는데 이 때 여러대의 호스트가 하나의 공인 IP 주소를 사용하여 인터넷에 접속.

			* www.naver.com을 주소창에 입력했을 때 화면이 나타나기까지의 과정
				1. 대기열, 캐싱, DNS, 라우팅, ARP, 초기연결을 거쳐 컨텐츠를 다운
				2. 브라우저렌더링 과정을 거쳐 네이버라는 화면이 나타남.
				(이러한 과정은 캡슐화 비캡슐화를 거쳐 이루어짐)

				(상세)
				1. 대기열
					- 브라우저는 주소창 입력에 대한 요청을 대기열에 넣는다.
				2. 캐싱
					- 요청된 값의 결과값을 저장하고, 그 값을 다시 요청하면 다시 제공하는 기술
					- 공유프록시캐시와 브라우저 캐시로 나눠짐.
						1. 브라우저 캐시
							- 쿠키, 로컬스토리지 등을 포함한 캐시.
							- 브라우저 자체가 사용자가 HTTP를 통해 다운로드하는 모든 문서를 보유하는 것.
							- 예) 어떤 사이트를 갔다가 다시 방문하면 굉장히 빠르게 컨텐츠가 나타남.
						2. 공유 프록시 캐시
							- 요청한 서버에서 프록시 서버가 캐싱을 하는 것.
				3. DNS
					- 브라우저가 요청의 IP 주소를 확인하는 단계.
					- 도메인 이름과 IP 주소를 매핑해주는 서버
						예) www.naver.com에 DNS쿼리가 오면 역순으로 [Root DNS] -> [.com DNS] -> [.naver DNS] -> [.www DNS] 과정을 거쳐 완벽한 주소를 찾아 IP 주소를 매핑.
					* 컴퓨터 메모리에 있는 호스트 파일 등 캐시를 확인한 후 캐시미스가 일어나면 DNS 서버로 요청한다.
				4. IP 라우팅
					- IP 라우팅, ARP 과정을 거쳐 실제 서버를 찾음.
				5. 초기 연결
					- 브라우저가 TCP 3웨이 핸드셰이크 및 SSL 연결을 통해 연결 설정.
					- 요청을 보낸 후 드디어 해당 요청한 서버로부터 응답을 받음.
				6. 콘텐츠 다운로드
					- 브라우저는 서버로부터의 응답을 수신함.
				7. 브라우저 렌더링
					- 받은 데이터를 바탕으로 브라우저 엔진이 브라우저렌더링 과정을 거쳐 화면을 만듬.

			- HTTP/1.x HTTP2의 차이점 그리고 HTTP3
				1. HTTP1.x
					-> 한 연결당 하나의 요청을 처리하도록 설계.
					-> RTT(Round Trip Time) 증가를 불러옴.
					-> HOL(Head-Of-Line) 블록킹 발생 가능성 높음 및 해결 못함.
				2. HTTP/2
					-> SPDY(speedy) 프로토콜에서 파생
					-> HTTP/1.x보다 지연 시간을 줄이고 응답 시간을 더 빠르게 할 수 있음
					-> 멀티플렉싱, 헤더 압축, 서버 푸시, 요청의 우선순위 처리를 지원
					-> HOL 해결.
				3. HTTP/3
					-> QUIC이라는 계층 위에서 돌아감
					-> UDP 기반으로 돌아가며 HTTP/2에서 장점이었던 멀티플렉싱 등을 가지고 있음.
					-> 초기 연결 설정 시 지연시간 감소라는 대표적 특성
					-> 순방향 오류 수정 메커니즘 특징
		- 암호화
			- 데이터를 '스크램블'한 방법
			- 복호화 하려면 송신자와 수신자가 서로 동의한 '키'가 필요
			* 이를 만들기 위해 키가 쓰이기도 함
				예) ciphertext = plaintext + key

			- 스크램블
				- 무작위 방식으로 개별 데이터 비트를 섞는 것.
					예) AES(128비트 고급 암호화) - 약 10회 스크램블되며 해독 오랜 시간 걸림.

			- 대칭 암호화
				- 키를 하나만 사용하는 암호화 방법. (AES, DES)

			- 비대칭 암호화
				- 공개키 암호화
				- 두개의 다른 키(공개키, 개인키)로 데이터를 암호화하거나 서명하고, 키 중 하나인 공개 키를 누구나 사용할 수 있도록 하는 방법.
				- 공개키로 암호화된 데이터는 개인키로만 복호화할 수 있게 함.
				- RSA, DH(Difie-Hellman)
				* TLS는 부분적으로 비대칭 암호화를 사용함(TLS1.3)
					-> 비대칭암호화로 인증을 한 후, 대칭 암호화로 보안적 통신 시작.
					-> TLS 핸드쉐이크 과정에서 처음 인증할 때 비대칭암호화를 하고, 그 이후 클라이언트와 서버는 "세션키"라고 하는 키를 기반으로 대칭 암호화를 기반으로 암호화된 통신을 함.
			- 필요성
				1. 의도된 수신자 또는 송신자를 제외하고는 통신을 하이재킹하여 읽을 수 없게 함.
				2. 민감한 데이터의 유출을 방지하고 데이터 무결성을 보장.

			- SSL(Secure Socket Layer : SSL 1.0, 2.0, 3.0
			- TLS(TransportLayer Security Protocol) : 1.0 ~ 1.3
				- 전송 계층에서 보안을 제공하는 프로토콜.
				- 클라이언트와 서버가 통신 할 때 TLS를 통해 제3자가 메시지를 도청하거나 변조하지 못하도록 함.
			- DH(Diffie-Hellman)
				- 서로 공개값 공유, 비밀값과 혼합, 혼합값과 공유, 각자의 비밀값과 혼합해서 공통의 암호키를 만드는 알고리즘.
			- 해싱 알고리즘
				- 데이터를 추정하기 힘든 거 작고, 섞여 있는 조각으로 만드는 알고리즘.
				- SHA-256 / SHA-384 알고르지므
				- SHA-256 : 해시 함수의 결괏값이 256비트인 알고리즘
				* 올바른 인증서 확인 시 전자서명을 이용하며 이 때 해싱 알고리즘 사용됨.
					1. 인증 생성작업 : 전자 서명을 만드는데 서명되는 메시지를 해싱
					2. 인증 확인작업 : 메시지를 복호화해서 해시를 서로 비교해 올바른 메시지인지 확인.
						- 유효성 검증 : 인증서가 변조되지 않았고, '서비스제공자' 것임을 확인하는 절차.
			- 인증서
				1. 주체(인증서를 발급한 CA, 도메인, 웹사이트 소유자, 인증서 소유자)
				2. 공개키(공개키, 공개키암호화방법)를 포함하는 단순한 데이터 파일.
				* 보통은 인증기관인 CA에서 발급한 SSL 인증서를 기반으로 인증 작업을 수행.
				-> 클라이언트가 접속한 서버가 클라이언트가 의도한 서버가 맞는지 확인할 때 쓰이고, 공개키는 처음 인증작업을 수행할 때 쓰임.

			- CA (Certificate Authority)
				- 인증서를 발급하는 기업들
				- 인증서를 구입할 때 아래 제출
					1. 서비스의 도메인
					2. 공개키와 같은 정보
				- 인증서의 종류
					- 단일 도메인 : 단 하나의 도메인에 적용되는 인증서
					- 와일드카드 : 도메인의 하위 도메인도 포함하는 인증서
						예) www.naver.com, blog.naver.com
					- 멀티 도메인 : 멀티 도메인 SSL 인증서는 관련되지 않은 다수의 도메인에 적용될 수 있는 인증서.
			- RSA의 취약점
				- 클라이언트가 생성한 임시 암호값을 서버로 전송
				<-> DH의 경우 클라이언트와 서버가 서로 교환한 DH 매개변수를 사용해 개인키를 만듬.
				- RSA는 클라이언트에서 생성한 임시 암호값이 탈취당하는 경우 해킹의 위험 존재.
				<-> DH의 경우 탈취당해도 공통의 암호키를 못 만들기 때문에 더 좋음.
			- 0-RTT
				- 세션키가 생성된 이 후 다시 그 사이트에 방문하면 미리 만들어 놓은 세션키(PSK:pre-shared-key)를 기반으로 연결을 생성하므로 인증에 드는 비용 없음. 
					--> 인증에 관한 RTT가 바생하지 않으므로 0-RTT라는 특징을 가짐.
			* HTTP/2는 HTTPS 위에서만 돌아감.

		- 웹브라우저의 캐시(로컬스토리지와 세션스토리지)
			1. 로컬 스토리지
				- 웹 브라우저에서 키 / 값 쌍의 형태로 클라이언트 브라우저에 데이터를 저장하는 방법
				- 데이터는 수동으로 삭제하지 않는 한 평생 동안 로컬 저장소에 저장됨.
				- 특징
					1. 저장된 데이터는 만료 날짜가 없음.
					2. 용량은 최대 10MB, 보통은 5MB
					3. 로컬 스토리지 데이터는 자동으로 서버로 전송되지 않음(쿠키는 자동 전송됨)
			2. 세션 스토리지
				- 탭을 닫을 때 삭제됨
				- 최대 5MB

			- 쿠키
				- 4KB
				- 클라이언트에 데이터를 저장하는 방법 중 하나.
				- 쿠키는 요청을 할 때 서버에 자동으로 전송됨.
				- 세션 쿠키
					- Expires 또는 Max-Age와 같은 속성을 지정하지 않은 것.
					- 브라우저가 닫힐 때 제거됨.
				- 영구 쿠키
					- Expires 또는 Max-Age와 같은 속성을 지정한 것
					- 브라우저를 닫을 때 만료되지 않으며 특정 날짜, 일정 기간이 지나면 제거됨.
				- secure
					- HTTPS로만 가능.
				- httponly
					- 공격자가 자바스크립트로 빼낼 수 없음 (document.cookie 불가)

		- HTTP 상태코드와 메소드 (GET, POST, PUT, PATCH, DELETE)
			(응답코드)
				- 1XX (정보) : 요청을 받았으며 프로세스를 계속함
				- 2XX (성공) : 요청을 성공적으로 받았으며 인식했고 수용
					- 200 OK : 요청이 성공적
					- 201 Created : 요청이 성공적, 새로운 리소스가 생성됨
				- 3XX (리다이렉션) : 요청 완료를 위해 추가 작업 조치 필요.
					- 301 Moved Permanently : 요청한 리소스의 URI가 변경됨
				- 4XX (클라이언트 오류) : 요청의 문법이 잘못되었거나 요청 처리 불가
					- 400 Bad Request : 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음.
					- 401 Unauthorized : 클라이언트의 인증이 되지 않음
				- 5XX(서버 오류) : 서버가 명백히 유효한 요청에 대한 충족을 실패함.
					- 500 Internal Server Error : 서버에 오류가 있음

			(메쏘드)
				- POST: 자원을 생성, 보통 하위자원을 생성.
				- GET: 읽기, 성공시 200, 오류의 경우 가장 자주 404(NOT FOUND) 또는 400(BAD REQUEST) 반환. (데이터를 수정, 삭제하는데 반드시 사용하면 안됨)
				- PUT : 업데이트(전체 자원), 요청을 보낼 때 전체를 보내야 함.
				- PATCH: 업데이트(일부 자원), 요청을 보낼 때 수정하는 일부분을 보내야 함.
				- DELETE: 삭제

				* PUT과 PATCH의 차이.
					- put은 전체 자원의 교체, patch는 일부 자원의 교체
					- 응답으로 받는 메시지는 수정된 결괏값과 동일해야 함.

		- 로그인 방식 : 쿠키와 세션 그리고 토큰방식(JWT)
			* Http의 특징: stateless
				- 연결을 끊는 순간, 사용자와 서버의 통신이 끝이 나며 상태 정보는 유지하지 않음.
					--> 로그인 상태를 유지하는 방법
						1) 쿠키와 세션
						2) 토큰기반 방식

				1) 쿠키와 세션 방식
					- 세션 : 서버와 클라이언트의 연결이 활성화된 상태
					- 세션ID : 웹 서버메모리에 저장되는 클라이언트에 대한 유니크한 ID
					- 쿠키
						1) 키-값으로 구성된 작은 데이터 조각
						2) 쿠키에 담긴 데이터는 브라우저에서 관리됨
						3) 이름, 값, 만료 날짜 등으로 구성
						4) 서버로 자동으로 보내짐.

					예) 보안 예
						1. 로그인 > 쿠키, 세션ID 생성.
							- 재요청시 HTTP 헤더에 쿠키를 포함시켜 요청(자동으로 됨)
						2. 쿠키에 맞는 세션ID로 전에 로그인했던 아이디인지 확인
						3. 로그인을 유지

					- 쿠키
						- XSS(Cross Site Scripting): 공격자들이 자바스크립트로 쿠리를 가로채고자 시도
						(해결방법)
							1. HTTP Only Cookie
								Set-Cookie: 쿠키명=쿠키값; path=/; HttpOnly
							2. Secure Cookie
								Set-Cookie: 쿠키명=쿠키값; path=/; secure

					- 쿠키 - 세션의 단점
						-> 로그인 중인 유저의 수가 늘어나면 서버의 메모리 과부화 등 악영향을 줌
						-> 로그인할때마다 세션ID를 저장해야 하므로.

				2) 토큰기반인증 방식
					- 인증은 토큰기반 인증서버를 통해 하고 다른 서버는 stateless하게 내버려두자는 이론이 담겨있는 인증방식.
						1. 요청 > 토큰생성
						2. 이후 사용자가 토큰을 헤더(authorization) 키에 넣어서 요청.
					* 토큰은 주로 JWT 토큰이 활용됨.

					- JWT(Json Web Token)
						- 헤더, 페이로드, 서명으로 이루어져 있으며 JSON 객체로 인코딩되며 메시지 인증, 암호화에 사용됨.
							- Header: 어떠한 방법의 서명 알고리즘을 사용할 겻인가에 대한 정보
							- PayLoad: 데이터, 토큰 발급자, 토큰 유효기간(인증이 필요한 최소한의 정보)
							- Signature: 헤더에 정의된 알고리즘으로 인코딩한 헤더와 페이로드를 합친 값, 비밀키를 기반으로 생성된 서명값.
						- 장점
							1. 인증시 사용자는 모든 시스템에서 사용할 수 있는 보안 토큰을 받음.
							2. 사용자 인증에 필요한 모든 정보는 토큰 자체에 포함됨(별도의 인증 저장소가 필요 없음)
								- 세션의 경우 계속해서 저장해야 함.
							3. 토큰 자체가 독립적.
						- 단점
							1. 더 많은 필드가 추가되면 토큰이 비대해져 트래픽에 영향이 있고 탈취하여 디코딩하면 데이터를 볼 수 있음.
					
		- REST API
			- Api란 SW와 SW 사이 데이터 전송을 가능케 하는 프로그램.
			- Uniform-Interface
				- 웹페이지를 변경했다고 브라우저를 업데이트하는 일은 없어야 함.
				- HTTP 명세나 HTML 명세가 변경되어도 웹페이지는 잘 작동되어야 함.
			(규칙)
			1. Self-Descriptive Messages
				- Http Header에 타입을 명시하고 각 메시지(자원)들은 MIME types에 맞춰 표현되어야 함.
			2. HATEOAS 구조
				- 하이퍼링크에 따라 다른 페이지를 보여줘야 하며 데이터마다 어떤 URL에서 원했는지 명시해주어야 함.
			3. Stateless
				- HTTP를 이용하면 HTTP 자체가 Stateless
			4. Cacheable
				- 캐싱된 데이터 유효성 판단: Last-modified, Etag
			5. Client-Server 구조
				- 클라이언트와 서버가 서로 독립적인 구조를 가져야 함.
			6. Layered System
				- 계층구조로 아키텍처를 만들 수 있다는 것을 뜻함.

			(URI 규칙)
			1. 동작은 HTTP 메소드로 해야 함. (PUT, DELETE, POST, GET)
			2. 확장자는 표기하지 말아야 함.
			3. 동사가 아닌 명사로만 표기해야 함.
			4. URI는 계층적인 내용을 담음 (예: 집/아파트/전세)
			5. 소문자로 쓰여 너무 길 경우에는 **-**를 사용
			6. HTTP 응답 상태 코드 활용.

		- 네트워크를 이루는 장치의 이해
			- 애플리케이션 계층 : L7 스위치
			- 전송 계층: L4 스위치
			- 인터넷 계층 : 라우터, L3 스위치
			- 데이터 링크 계층 : L2 스위치, 브리지
			- 물리 계층 : NIC, 리피터, AP

			1) 애플리케이션 계층
				- L7 스위치
					- 로드밸런스라고도 하며, 서버의 부하를 분산하는 기기.
					- 서버이중화, 보안에 강점
					- 헬스 체크: L4, L7 스위치 모두 헬스 치크를 통해 정상 / 비정상 서버 판별
						(전송 주기와 재전송 횟수 등을 설정한 이후 반복적으로 서버에 요청을 보냄)
			2) 전송 계층
				- L4 스위치
					- 부하분산
					- 상위계층의 패킷을 분석해 트래픽의 우선순위를 부여할 수 있음.
					- 헤더를 분석해서 부하 분산을 할 수 있음.

			3) 인터넷 계층
				- 라우터
					- 라우팅을 하는 장비 / 하나 이상의 네트워크에서 경로를 선택하는 프로세스.
					- 다른 네트워크에 존재하는 장치끼리 서로 데이터를 주고받을 때 '패킷소모 최소화', '경로 최적화' 하는 장비.
				- L3 스위치
					- L2 스위치 기능 + 라우팅
					- 소프트웨어 기반, 하드웨어 기반 라우팅을 하는 것으로 나눠지는데 하드웨어 기반의 라우팅을 담당하는 장치가 L3 스위치.

			4) 데이터 링크 계층
				- L2 스위치
					- 장치들의 MAC 주소를 MAC 주소 테이블을 통해 관리, 연결된 장치로부터 패킷이 왔을 때 패킷 전송을 담당
				- 브리지
					- 두 개의 근거리 통신망(LAN)을 상호 접속할 수 있도록 하는 통신망 연결 장치

			5) 물리 계층
				- NIC
					- LAN 카드라고 하는 네트워크 인터페이스 카드(Network Interface Card)
				- 리피터
					- 들어오는 약해진 신호 정도를 증폭하여 다른 쪽으로 전달하는 장치

		- 전이중화(full duplex): 양쪽 장치가 동시에 송수신할 수 있는 방식
		
		- CSMA / CD (Carrier sense Multiple Access with Collision Detection)
			- 데이터를 보낸 이후 충돌이 발생하면 일정 시간 이후 재전송하는 방식.

		- 반이중화 통신
			- 양쪽 장치는 서로 통신할 수 있지만, 동시에는 통신할 수 없으며 한번에 한 방향만 통신할 수 있는 방식.
			- CSMA / CA 반이중화 통신 중 하나
				- 장치에서 데이터를 보내기 전에 캐리어 감지 등으로 사전에 가능한 충돌을 방지하는 방식을 사용.

		- 와이파이 : 전자기기들이 무선 LAN 신호에 연결할 수 있게 하는 기술.
		- BSS(Basic Service Set) : 기본 서비스 집합
			- 동일 BSS 내에 있는 AP들과 장치들이 서로 통신이 가능한 구조.

		- ESS(Extended Service Set): 하나 이상의 연결된 BSS 그룹.

		- 주파수
			- 2.4GHZ 
				- 장애물에 강함
				- 호환성 좋음 (오래된 노트북, 휴대폰과도 연결가능)
				- 전자레인지, 무선 등 전파 간섭이 일어나기도 함.
				- 커퍼리지가 적음.
			- 5GHZ
				- 사용할 수 있는 채널 많음.
				- 상대적으로 깨긋한 전파환경
				- 속도가 더 빠름
				- 커버리지가 작음.

		- 로드밸런서: 트래픽 분산을 위해 사용
			- 한 서버에 장애가 발생하면 트개픽을 다른 기능 서버로 리다이렉션하여 시스템 중단 방지 가능.

		- 블랙스완 프로토콜
			- 시스템이 다운되면 다음과 같은 수칙을 따름
				1. 영향 받은 시스템과 각 시스템의 상대적 위험 수준 확인
				2. 잠재적으로 영향을 받을 수 있는 내부의 모든 팀에 연락
				3. 최대한 빨리 취약점에 영향을 받는 모든 시스템 업데이트
				4. 복원계획을 포함한 우리의 대응 과정을 파트너와 고객 등 외부에 전달.

		- 서킷 브레이커
			- 외부 서비스의 장애로 인한 연쇄적 장애 전파를 막기 위해 자동으로 외부 서비스의 연결을 차단 및 복구하는 것.
			- 보통 MSA를 할 때 장착함.
			- closed, open, half_open의 상태값을 가짐.
				1. closed: 네트워크 요청의 실패율이 임계치보다 낮음. (정상)
				2. open: 임계치 이상의 상태. 요청을 전송하지 않고 바로 오류 반환. (fail fast)
				3. half_open: open 상태에서 일정 timeout으로 설정된 시간이 지나면 장애가 해결되었는지 확인하기 위해 half_open 상태로 전환. 여기서 요청을 전송하여 응답을 확인. 장애가 풀리는지를 확인해서 성공하면 closed, 실패하면 open으로 변경.
















