4. 데이터베이스
	- 데이터베이스: 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
	- 엔터티: 사람 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사
	- 릴레이션: 데이터베이스에서 정보를 구분하여 저장하는 기본 단위, 관계형 데이터베이스에서는 '테이블'이라고 하며, NoSQL 데이터베이스에서는 '컬렉션'이라고 함.
	- 속성: 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
	- 도메인: 릴레이션에 포함된 각각의 속성들이 가질 수 있는 값의 집합

	(테이블과 컬렉션의 차이)
	- MySQL: 레코드-테이블-데이터베이스로 이루어져 있음
	- MongoDB: 도큐먼트-컬렉션-데이터베이스로 이루어져 있음.

	- 필드와 레코드, 타입
		1. 숫자 - INT
			- 4byte: -21억 ~ 21억
		2. 날짜 타입
			- DATE: 날짜만, 시간x, 3바이트
			- DATETIME: 날짜 + 시간 / 8바이트
			- TIMESTAMP: 날짜 + 시간 / 4바이트 / 1970-01-01 00:00:01에서 카운트 값
		3. 문자 타입 
			- CHAR: 테이블을 생성할 때 선언한 길이로 고정(0~255 사이의 값)
			- VARCHAR: 가변 길이 문자열, 길이는 0 ~ 65,535(2바이트, 16비트)
			(차이점)
				-> Char은 4바이트씩 저장, VARCHAR는 유동적으로 저장됨.
	- 관계, 키
		- 기본키(Primary Key): 유일성과 최소성을 만족함.
		- 자연키: 중복되는 것을 제외하고 자연스럽게 뽑아 결정하는 기본키, 언젠가 변함
		- 인조키: MySQL의 auto increment 등 인조적으로 유일성을 확보하는 키
		- 외래키: 다른 테이블의 기본키를 그대로 참조하는 값
		- 후보키: 기본키가 될 수 있는 호부들이며 유일성과 최소성을 동시에 만족하는 키
		- 대체키: 후보키가 두 개 이상일 경우 어느 하나를 기본키로 지정하고 남은 후보키들
		- 슈퍼키: 각 레코드를 유일하게 식별할 수 있는 유일성을 갖춘 키.

	- ERD의 기본 (Entity Relation Diagram)
		- 릴레이션 간의 관계들을 정의한 것
		- 시스템의 요구 사항을 기반으로 작성되며 데이터베이스를 구축

	- 트랜잭션, 커밋, 롤백 그리고 트랜잭션 전파
		- 트랜잭션: 데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위(쿼리를 묶는 단위)
		- 커밋: 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어, 트랜잭션 단위로 수행되며 변경된 내용이 모두 영구적으로 저장
		- 롤백: 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일(취소)
		- 트랜잭션 전파: 트랜잭션 수행은 커넥션 단위로 수행하므로 커넥션 객체를 넘겨서 수행해야 함, 이를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 하는 것.

	- ACID(트랜잭션의 특징)
		1. 원자성(Atomicity)
			- 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장
		2. 일관성(Consistency)
			- '허용된 방식'으로만 데이터를 변경해야 하는 것을 의미
		3. 격리성(Isolation)
			- 트랜잭션 수행 시 서로 끼어들지 못해야 함
		4. 지속성(Durability)
			- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함

		(기타) 무결성(Integrity)
			- 데이터의 정확성, 일관성, 유효성을 유지

	- 트랜잭션의 격리성
		- Transaction Isolation
			* 트랜잭션이 순차적으로 실행 되면 격리성은 높아지지만 동시성은 낮아져서 성능이 안좋아짐.
			* 격리성과 동시성은 반비례 관계

		- 팬텀리드(Phantom Read)
			- 한 트랜잭션 내에서 동일한 쿼리를 2번 이상 보냈을 때 해당 조회 결과가 다름.

		- 반복 가능하지 않은 조회(Nonrepeatable Reads)
			- 한 트랜잭션 내의 같은 행에 두 번 이상조회가 발생했는데, 그 값이 다른 것

		- 더티 리드(Dirty Reads)
			- 하나의 트랜잭션이 다른 트랜잭션의 아직 커밋되지 않은 데이터를 읽는 현상.

	- 트랜잭션의 격리수준
		- Serializable
			- 커밋 완료된 데이터에 대해서만 조회할 수 있으며 트랜잭션을 순차적으로 진행시키는 것.
			- 여러 트랜잭션이 동시에 같은 행에 접근할 수 없음.

		- REPEATABLE_READ
			- 커밋 완료된 데이터에 대해서만 조회 가능.
			- 반복해서 행을 조회하더라도 똑같은 행을 보장하는 단계.
			* 팬텀리드 발생 가능

		- READ_COMMITED
			- 커밋 완료된 데이터에 대해서만 조회 가능
			- 가장 많이 사용되는 격리 수준
			* 팬텀리드, 반복하지 않은 조회 발생 가능

		- READ_UNCOMMITTED
			- 가장 낮은 격리 수준이며 가장 빠름.
			- 다른 트랜잭션이 커밋하지 않은 정보를 읽을 수 있음
			* 팬텀리드, 반복 가능하지 않은 조회, 더티리드가 일어날 수 있음.

	- 관계형 데이터베이스, NoSQL
		- 관계형 데이터베이스: 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스
			- SQL 언어를 써서 조작
		- NoSQL 데이터베이스: SQL을 사용하지 않는 데이터베이스
			- 유연한 스키마, 확장성이 특징

		1. NoSQL
			- Key-Value 형태의 도큐먼트

	- 클러스터형 인덱스 Vs 비클러스터형 인덱스
		- Clustered Index
			- 유일성과 최소성을 가지는 기본키 중 하나로 설정
			- 테이블당 한개, 보통 테이블의 기본키가 클러스터형 인덱스가 됨.
			- 데이터 페이지가 정렬되서 저장되며 인덱스 페이지의 리프노드에 '데이터 페이지'가 들어가 있음. (정렬되어 있으므로 탐색에 장점)
			- 데이터가 추가될 때마다 다시 모든 테이블을 정렬해야 하기 때문에 삽입, 삭제, 수정이 느림.
			- 인덱스의 순서와 데이터의 순서가 일치함.
			* 인덱스 생성 방법: Primary Key

		- Non-Clustered Index
			- 보조인덱스, 여러 개 생성 가능
			- 클러스터형과 달리 인덱스 페이지 리프노드에 실제 데이터가 있는 것이 아닌 데이터 페이지에 관한 포인터가 있음.
			- 정렬되어 있지 않아서 탐색은 느리나, 삽입, 삭제, 수정이 빠름
			- 인덱스의 순서와 데이터의 순서가 일치하지 않음.

	- 내부조인, 왼쪽조인, 오른쪽조인, 합집합 조인의 차이.
		- 내부 조인(inner join)
			- 두 테이블 두 행이 모두 일치하는 부분만 표기
		- 왼쪽 조인(left outer join)
			- 왼쪽 테이블의 모든 행이 결과 테이블에 표기됨
		- 오른쪽 조인(right outer join)
			- 오른쪽 테이블의 모든 행이 결과 테이블에 표기됨.
		- 합집합 조인(Full outer join)
			- 두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기

	- 중첩루프조인, 정렬병합조인, 해시조인
		- 중첩 루프 조인: 중첩 for 문과 같은 원리로 조건에 맞는 조인
		- 정렬 병합 조인: 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인 <, > 조건에 많이 쓰임.
		- 해시 조인: == 조건에만 쓰임. 두 개의 테이블을 조인한다고 했을 때 바이트상 더 작은 테이블을 해시테이블로 만들어서 조인.

	- 데드락
		- 데이터베이스의 교착상태 (둘 이상의 트랜잭션이 서로가 잠금을 포기하기를 기다리는 상황)

	- 교착상태 감지
		1. 교착상태 감지 및 timeout
			- 일정시간 이후 트랜잭션이 실행되지 않았을 경우 롤백

		2. 그래프 기반으로 사이클 탐색
			- 그래프 내의 사이클이 형성 되었다는 것을 기반으로 교착상태 감지.
			* 대규모 데이터베이스의 경우 이를 일일히 감지하기에는 코스트가 너무 크므로 교착상태방지를 많이 사용

		3. 교착상태방지
			- 최대한 교착상태가 일어나지 않게 방지
			
			1) 격리 수준 변경
				- 격리 수준을 행수준 잠금 또는 조정하는 것.

			2) 서비스의 로직을 교차되지 않게 수정
				- 서비스의 논리구조를 바꾸는 것(교차되지 않도록)

			3) wait-die 또는 wound wait 방법
				- 타임스탬프를 기반으로 트랜잭션을 대기, 선점, 종료하는 방식
				- Wait-Die: 트랜잭션 방지를 위한 비선점기법
					- 대기하거나 죽거나
					- 늙은 것이 요구하면 대기, 젊은 것이 요구하면 젊은 것은 죽는 것

				- wound-wait
					- 교착 상태 방지를 위한 선점 기법
					- 상처를 입거나 대기하거나
					- 늙은 것이 요구하면 젊은 것은 강제로 일시정지, 데이터는 늙은이의 것, 젊은 것이 요구하면 대기.

	- 데티어베이스 정규화 과정
		- 정규화 과정 : 릴레이션 간의 잘못된 함수 종속 관계로 인해 데이터베이스 이상 현상이 일어나는 것을 해결하는 과정이자 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리하는 과정.

		- 이상현상(Anomaly)
			- DB 설계 잘못하게 되었을 때 불필요한 데이터 중복이 발생하는 것
			- 데이터의 삽입, 갱신, 삭제 연산을 수행할 때 부작용 발생

		- 함수적 종속성(Functional Dependency)

		- 제 1정규형
			- 릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값(atomic value)만으로 구성되어야 함.

		- 제 2정규형
			- 릴레이션이 제 1정규형이며 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속된 것을 말함
			* 무손실분해: 분해했을 때 정보손실이 발생하지 않아야 함.

		- 제 3정규형
			- 제 2정규형이고 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속(Transitivie Functional Dependency)을 만족하지 않는 상태

			* 이행적 함수종속 : A->B와 B->C가 존재하면 논리적으로 A->C가 성립, 이 때 C가 집합 A에 이행적으로 함수 종속이 되었다고 함.

		- 보이스 / 코드 정규형
			- 보이스 / 코드 정규형(BCNF)은 제 3정규형이고, 모든 결정자가 후보키인 상태
		
		(정규화 과정)
			1. 제 1정규형(모든 속성이 원자값)
			2. 제 2정규형(모든 속성, 기본키에 완전 함수 종속)
			3. 제 3정규형(기본키에 이행적 함수종속X)
			4. 보이스 / 코드 정규형(모든 결정자가 후보키)

		* 정규화 과정 : 릴레이션(테이블)을 나누는 과정.
			- 테이블을 나누게 되면 성능이 좋아질 수도 나빠질 수도 있음.
				- '조인'을 계속 해야 하므로 오히려 느려질 수도 있음
				- '조인'이 많이 필요할 경우 어느정도 비정규화가 필요함.
			- 정규화 과정은 중복 데이터가 제거됨에 따라 스토리지에 대한 전체 메모리 요구량이 감소하게 됨.
			- 테이블이 더 정상적이게 되므로 오류 발생 가능성 줄어듬.

		* 조인은 코스트가 큼.
			- 테이블 X에 N개의 레코드가 있고 테이블 Y에 M개의 레코드가 있는 경우 X와 Y를 조인하면 N*M개의 레코드가 있는 임시 테이블이 생성됨.







