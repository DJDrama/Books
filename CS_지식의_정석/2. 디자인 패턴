[디자인 패턴]
    - 프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 ‘규약’ 형태
    - 라이브러리
        - 공통으로 사용될 수 있는 특정 기능들을 모듈화 한 것.
        - 폴더명, 파일명 등에 대한 규칙이 없고 프레임워크에 비해 자유로움.
    - 프레임워크
        - 공통으로 사용될 수 있는 특정 기능들을 모듈화 한 것.
            - 폴더명, 파일명 등에 대한 규칙이 있으며 라이브러리에 비해 좀 더 엄격함.
    - 싱글톤 패턴
        - 하나의 클래스에 하나의 인스턴스만 가지는 패턴
        - 데이터베이스 연결모듈에 많이 사용됨
        - 인스턴스 생성에 장점, 의존성이 높아지고, TDD에 단점.
        1. 단순한 메서드 호출
            - 원자성 결여
            - 멀티스레드 환경에서는 싱글톤 인스턴스를 2개 이상 만들 수 있게 됨.
        2. Synchronized
            - 인스턴스를 반환하기 전까지 격리 공간에 놓기 위해 synchronized 키워드로 잠금 가능
            - 최초로 접근한 스레드가 해당 메서드 호출시, 다른 스레드가 접근하지 못하도록 잠금을 걸어줌.
            - getInstance() 메서드를 호출할 때마다 잠금이 걸려 성능저하. (인스턴스가 만들어져도 getInstance() 호출이 가능하므로)
        3. 정적 멤버
            - 미리 인스턴스를 생성하는 방법
            - 클래스 로딩과 동시에 싱글톤 인스턴스를 만듬.
            - 모듈들이 싱글톤 인스턴스를 요청할 때 그냥 만들어진 인스턴스를 반환하면 됨.
            - 문제점: 불필요한 자원낭비
                - 싱글톤 인스턴스가 필요없는 경우도 무조건 싱글톤 클래스를 호출해 인스턴스를 만들어야 하기 때문.
        4. 정적 블록
        5. 정적 멤버와 Lazy Holder(중첩 클래스)
            - getInstance()가 호출될 때 singleInstanceHolder 클래스가 로딩되어 인스턴스를 생성.
        6. 이중 확인 잠금(DCL - Double Checked Locking)
            - 인스턴스 생성 여부를 싱글톤 패턴 잠금 전에 한번, 객체를 생성하기 전에 한번 2번 체크하며 인스턴스가 존재하지 않을 때만 잠금을 걸 수 있음)
            - Volatile
                - 메인 메모리 위에 CPU 캐시메모리라고 불리는 L3, L2, L1 캐시가 존재. (L4까지 CPU 캐시 메모리라고 부름)
                - Java에서는 스레드 2개가 열리면 변수를 메인 메모리(RAM)에서 가져오는 것이 아닌, 캐시메모리에서 각각의 캐시메모리를 기반으로 가져옴.
                    - Volatile 키워드를 추가해서 Main Memory(RAM)를 기반으로 저장하고 읽어오기 때문에 변수 값 불일치 해결 가능.
        7. Enum 방식
            - Enum은 기본적으로 Thread Safe함
        - 최고의 방법: 5번 DCL, 7번 Enum 방식. (5번이 가장 많이 사용되며, 7번은 조슈아 블로크가 추천한 방법)
    - 의존성 주입
        - 메인 모듈이 ‘직접’ 다른 하위 모듈에 대한 의존성을 주기보다는 중간에 의존성 주입자(dependency injector)가 이 부분을 가로채 메인 모듈이 ‘간접’적으로 의존성을 주입하는 방식.
        - 장점
            - 모듈을 쉽게 교체할 수 있음.
            - 테스팅하기 쉽고 마이그레이션하기 수월함
            - 앱의 의존성 방향이 좀 더 일관되어 추론하기 쉬움.
            - 객체들을 쉽게 교체할 수 있는 코드가 됨.
        - 단점
            - 모듈들이 더욱더 분리되므로 클래스 수가 늘어남
            - 복잡성이 증가하며 코스트가 듬(클래스 폭발)
    - 팩토리 패턴
        - 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴 / 상속 관계에 있는 두 클래스에서 상위 클래스가 중요한 뼈대를 결정하고, 하위클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴.
    - 이터레이터 패턴
        - 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴
        - 각기 다른 컬렉션들을 똑같은 인터페이스로 순회가 쉽다는 장점
    - 전략 패턴
        - 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않는다.
        - '캡슐화한 알고리즘'을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴
        - 실제 라이브러리로는 인증모듈에 쓰이는 passport가 있음.
    - 옵저버 패턴
        - 주체가 어떤 객체의 상태 변화를 관찰하다가 상태 변화가 있을 때마다 메서드 등을 통해 옵저버 목록에 있는 옵저버들에게 변화를 알려주는 패턴.
    - 프록시 패턴
        - 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 객체 앞단의 인터페이스 역할을 하는 디자인 패턴.
        - 서버 앞단에 두어 캐싱, 로깅 등에 활용하는 프록시 서버가 대표적.

    - MVC 패턴 : Model, View, Controller
    - MVP 패턴 : Model, View, Presenter (View와 Presenter는 일대일 관계이므로 MVC보다 강한 결합을 지닌 디자인 패턴)
    - MVVM 패턴 : Model, View, ViewModel (VM은 View를 추상화한 계층)
        - VM: V = 1:N (여러 View가 하나의 ViewModel을 사용가능)
        - 커맨드와 데이터 바인딩을 가짐.
        - 뷰와 뷰모델 사이의 양방향 데이터 바인딩을 지원하며 UI를 별도의 코드 수정없이 재사용이 가능하고 단위 테스팅이 쉬움.
        - 커맨드
            - 여러 요소에 대한 처리를 하나의 액션으로 처리할 수 있는 기법
            - 데이터바인딩
            - 화면에 보이는 데이터와 브라우저 상의 메모리 데이터를 일치시키는 방법
            - 뷰모델을 변경하면 뷰가 변경됨.

    - 의존성 주입과 전략 패턴의 차이
        - 전략 패턴: 의도에 초점을 맞추고 동일한 행동 계약을 준수하는 다양한 구현으로 인터페이스를 만들도록 권장하는 것을 포함.
        - 의존성 주입: 일부 동작을 구현하고 의존성을 주입하기만 하는 패턴.

    - 프로그래밍 컨텍스트란?
        1. 어떤 종류의 상태, 환경을 캡슐화한 것
        2. 작업이 중단되고 나중에 같은 지점에서 계속 될 수 있도록 저장하는 최소 데이터 집합.(컨텍스트 스위칭)

    - Static의 단점
        1. 동시성 문제 : 값이 변경되면 참조하는 모든 스레드에 영향을 주기에 사이드 이펙트 발생
        2. 메모리 문제 : 클래스가 생성될 때 메모리를 할당, 사용하지 않아도 메모리가 할당되어 있음. 단, 클래스에 집어넣은 메서드의 경우 사용하지 않을 경우 메모리 할당이 일어나지 않음.
        3. 테스트 문제 : static인 경우 단위적이지 않고 전역적으로 관리되므로 해당 부분을 깨끗하게 테스팅하기 어려움.
