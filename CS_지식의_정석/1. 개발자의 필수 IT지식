CS 지식의 정석

[개발자의 필수 IT 지식]
1. 데이터포맷 #1.JSON
    - 데이터: 이론을 세우는 데 기초가 되는 사실. 또는 바탕이 되는 자료나 관찰이나 실험, 조사로 얻은 사실이나 자료 등을 의미
    - 데이터를 컴퓨터가 주고 받으려면 어떤 약속을 정하고 주고받아야 함.
    - JSON
        - JavaScript Object Notation : 자바스크립트 객체 문법으로 구조화된 데이터를 표현하기 위한 표준 포맷
        - undefined를 제외한 기본 데이터 타입인 문자열, 숫자, 배열, 불리언 그리고 다른 객체를 포함할 수 있음.
        - Key: Value 형태
        - 배열은 [] 를 감싸서 표현.
        - 각 객체는 다른 타입을 가지고 있어도 괜찮음.
    - JSON 참조방법
        - Key에 대한 value는 Key 또는 [‘key’] 형태로 접근해서 빼내면 됨
    - JSON 주의할 점
        - Json은 순수 데이터 포맷 (오직 Key-Value들만 담을 수 있음 <-> 메소드는 담을 수 없다)
        - 큰 따옴표만 사용해야 하며 undefined는 불가능.
    - JSON의 자료형
        - Number
        - String
        - Boolean
        - Array
        - Object
        - Null
    - JSON의 장점
        - 텍스트로 이루어짐
        - 사람과 컴퓨터 모두 읽고 쓰기가 쉽다.(바이트가 아니므로)
        - 프로그래밍 언어와 플랫폼에 독립적 (서로 다른 시스템간에 객체를 교환하기에 좋음)
        - 주로 API, config 파일에 활용되며 가벼움.
2. 데이터포맷 #2.XML
    - Extensible Markup Language
    - 중괄호가 아닌 열린 태그와 닫힌 태그로 이루어진 구조의 데이터.
    - <?xml version=“1.0” encoding=“UTF-8”?>
        - Xml 옆에 version, encoding을 쓴다.
        - 보통은 utf-8이며 이 한줄을 “프롤로그”라고 한다.
    - XML은 닫힌 태그가 계속해서 들어가므로 JSON과 비교하면 무겁다.
    - Javascript Object로 변환하기 위해서는 JSON보다 더 많은 노력이 필요함.
    - XML에는 기본 제공 이름이 없음.
    - 대표적으로 sitemap.xml에 쓰인다.
3. API
    - Application Programming Interface
        - 둘 이상의 컴퓨터 프로그램이 서로 통신하는 방법
        - 컴퓨터 사이에 있는 중계 계층을 의미
    - 과거부터 라이브러리 및 프레임워크를 설명하는 명세서
    - 웹상에서 WEB API, Web Socket API 등을 가리키는데 현재를 기준으로 API라고 할 때 보통 WEB API를 기준으로 설명됨.
    - 구조
        - 브라우저를 통해서 서버에 요청을 하게 되면, API가 중계계층역할을 하며 요청을 처리.
        - 직접 서버의 데이터베이스에 접근 하는 것을 방지
    - 장점
        - 제공자는 서비스의 중요한 부분을 드러내지 않아도 됨.
            - 예) DB 설계 구조나 드러내고 싶지 않은 데이터베이스의 테이블 정보, 서버의 상수값 등을 드러내지 않고 드러내고 싶은 부분만을 드러낼 수 있다.
        - 사용자는 해당 서비스가 어떻게 구현되는지 알 필요없이 필요한 정보만을 받을 수 있다.
        - OPEN API의 경우 앱 개발 프로세스를 단순화 시키고 시간과 비용을 절약할 수 있다.
        - 제공자의 경우 API를 만들면 내부 프로세스가 수정되었을 때 매번 수정하는 것이 아닌 API가 수정이 안되게끔 만들 수 있다.
            - 또한 내부가 변경이 되어도 사용자에게 영향을 주지 않고 변경이 가능하다.
        - 제공자는 데이터를 한곳에 모을 수 있다.
            - 예) 어떠한 API를 만들고 해당 이벤트가 발생하면 해당 API를 호출하게 만들면 해당 데이터를 한 곳에 모을 수 있다.
        - 제공자의 경우, API를 이용해 제3자가 만들어낸 앱을 통해 데이터를 수집할 수 있고, 해당 서비스를 확장해 나갈 수 있으며 홍보에도 도움이 된다.
    - API의 종류
        - Private: 내부적 사용.
            - 주로 해시키를 하드코딩하고, 이를 기반으로 서버와 서버간의 통신함.
            - 비즈니스 파트너와 사용가능, 해당 파트너와 해시키를 공유해 통신.
        - Public: 모든 사람이 사용 가능.
            - 많은 트래픽을 방지하기 위해 하루 요청수의 제한, 계정당 몇개 등으로 관리.
4. 클라우드, Saas, IaaS, PaaS
    - 클라우드
        - ‘인터넷’을 통해 접근할 수 있는 서버 그리고 그 안에서 구동되는 소프트웨어, 데이터베이스 등을 의미
        - 나의 컴퓨터 장비를 사용하지 않고, 컴퓨터 장비를 구축해 해야할 작업을 온라인에 분산되어 존재하는 데이터 센터에 맡겨 수행하는 것을 의미(IDC - Internet Data Center)
            - Off-premise(오프프레미스 방식): 서버를 직접 구매할 때 고려해야 할 전력, 위치, 서버 세팅, 확장성을 고민하지 않고 서비스 운영에만 집중 가능
                - 예) 네이버 데이터 센터(춘천에 위치)
                - 최대 장점: ‘프리쿨링’을 통한 전기 절약 가능 (서버실 온도를 조절하기 위한 냉각수를 전기가 아닌 외부 찬 공기를 이용해 만드는 방식)
                    - 데이터센터 냉각시설의 효율화를 위해 강원도로 자리잡음(춘천은 연중 최대 6개월까지 프리쿨링이 가능하다)
            - On-premise(온프레미스 방식): 기업이나 개인이 자체 시설에서 보유하고 직접 유지 관리하는 프라이빗 데이터 센터
                - SaaS : Software as a Service (인터넷을 통해 소프트웨어를 제공, 완제품)
                    - 예) 구글 드라이브, N드라이브, 구글 Docs 등
                        - 다른 컴퓨터에서도 쉽게 작업, 다른 사람과의 실시간 공유작업 가능.
                - IaaS : Infrastructure as a Service (인프라를 제공 - 서버와 저장소를 제공)
                    - 빈 방을 주는 것.
                    - 가상머신 위에서 어플리케이션의 각 컴포넌트가 구동됨
                    - 특정 클라우드에 종속되지 않으며, 운영비가 상승, 이식성이 좋음
                    - 예) AWS의 EC2, NCP등이 있음.
                    - 가상머신: 가상 컴퓨터, 컴퓨터 시스템을 에뮬레이션하는 소프트웨어
                - PaaS: Platform as a Service (플랫폼을 제공)
                    - 빌트인 방
                    - 운영비 절감 가능
                    - 모니터링, CI/CD 제공
                    - IaaS보다는 유연하지 않으며 플랫폼에 종속되게 되어있음. Heroku등이 있음.
                    - 특정 클라우드 서비스에 종속된다.
                - PaaS vs IaaS
                    - PaaS
                        - 유연하지 않음
                        - 플랫폼에 종속
                        - 이식성 낮음
                        - 운영비 효율 좋음
                    - IaaS
                        - 유연함
                        - 플랫폼에 종속되지 않음
                        - 이식성 높음
                        - 운영비 효율 낮음
                - 도커, 컨테이너 (IaaS의 이식성, PaaS의 운영비를 갖춘 도커를 이용한 클라우드)
                    - 전통적 배포
                        - 물리적인 컴퓨터 한 대에 하나의 OS를 깔고 여러 가지 프로그램을 설치하는 방식
                        - 어떤 프로그램을 설치했을 때 다른 앱에 영향을 미침.
                    - 가상화 배포
                        - 가상머신을 기반으로 배포
                        - Hypervisor: 하나의 시스템 상에서 가상 컴퓨터를 여러개 구동할 수 있도록 해 주는 중간 계층을 의미
                            - 컴퓨터 한대로 여러개의 앱을 독립적으로 돌릴 수 있다.
                            - 클라우드 : 가상화 기술 때문에 클라우드 컴퓨팅이 가능
                            - 가상머신: 컴퓨터의 모든 부품을 에뮬레이션(모든 부품의 기능을 소프트웨어적으로 구현)한 것.
                                - 하나의 컴퓨터 위의 여러개의 가상머신을 둘 수 있음.
                                - 이는 서로 샌드박스되어 전혀 상호 작용하지 않고, 한 가상 머신위의 프로그램은 다른 가상머신위의 프로그램에서 볼 수 없음.
                                - OS가 공유되지 않으므로 전통적 배포보다는 아니지만 가상머신에 일일히 OS를 설치해야 하는 비용이 많이 듬.
                    - 컨테이너 배포
                        - 코드와 모든 종속성(라이브러리)를 패키징하는 소프트웨어의 표준 단위.
                        - ‘이미지’라고 하는 파일에 모든 라이브러리와 종속성을 포함하는 코드 기반 파일에 저장됨.
                        - 컨테이너: VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 OS를 공유하며 가상머신보다 경량화 되어있음.
                        - OS를 공유할 수 있기에 실행이 빠르며 가상화 배포보다 약 5배의 애플리케이션을 실행할 수 있음.
                        - 컨테이너나 VM은 애플리케이션이 ‘서로 다른 컴퓨터에서 설치되어 있다’라고 생각하게 만듬.
                            - 두 프로그램 간에 간섭을 일으킬 수 없는 장벽을 침.
                        - 다만, OS를 공유하므로 애플리케이션의 문제가 OS에 영향을 미치면 OS에서 구동 중인 전체 컨테이너의 문제가 될 가능성이 높음.
                - 도커
                    - 컨테이너라는 경량 단위로 애플리케이션을 실행하는 기능을 제공하는 플랫폼
                    - 여러 컴퓨터 간에 공유된 규격으로 리소스를 공유할 수 있어 유지보수성이 증대됨.
                    - IaaS의 장점인 이식성, PaaS의 장점인 운영비가 저렴함을 갖춘 도구.
                    - 기존의 종속적인 라이브러리나 ~~파일을 ~로 복사 등 기존 시스템에 대한 설치 절차를 Dockerfile 스크립트에 작성하기만 하고 배포 관련사항을 도커스웜이나 쿠버네티스에 맞춰 작성하기만 하면 됨.
                    - 보통 도커 + 쿠버네티스, 또는 도커 + 도커스웜으로 구축됨.
                    - 컨테이너 생성 과정
                        - 도커파일이 빌드
                        - 도커이미지 생성 및 실행
                        - 도커 컨테이너 실행
                    - 도커파일 : 컨테이너에 설치해야하는 패키지, 환경변수설정 등을 기록한 하나의 파일
                    - 도커이미지: 도커가 도커파일의 단계에 따라 컴퓨터의 상태를 ‘스냅샷’으로 저장한 것
                    - 컨테이너: 도커가 이미지를 불러와 실행할 때 생성됨. 실행중인 컨테이너는 이미지에 지정된 프로그램과 데이터를 사용해 일반적인 실제 컴퓨터와 연결되어 사용가능
                    - 도커는 ‘클라우드 가상화기술’이며 PaaS의 일부
                        - 컨테이너의 가상화는 커널 레벨이 아닌 OS 레벨, 가상 머신의 가상화가 일어나느 곳에서 한 추상화 계층 높은 곳에서 일어남.
        - 정적 타입시스템의 필요성
            - 타입시스템이란?
                - 언어의 기본 타입 또는 개발자가 정의한 타입을 기반으로 해당 타입을 언어와 연관시키는 메커니즘.
                - 타입 동등, 타입 호환, 타입 추론에 대한 규칙을 지킨다면 타입시스템이라 볼 수 있음.
                    - 동등 : 두 타입이 동일할 때 적용되는 규칙 (int = int)
                    - 호환: 두가지 타입이 정확이 일치하지 않아도 호환이 되는지를 나타내는 규칙 (any = int)
                    - 추론: 타입이 정의되어 있지 않지만 주변 문맥에 따라 타입이 결정되는 규칙(a=3일 때 a는 int)
                - 동적 타입 : PHP, JS, Python (런타임에 모든 변수의 유형을 결정하고 잘못된 경우 예외 발생)
                - 정적 타입: C, C++, JAVA, Kotlin (컴파일 타임에 모든 변수의 유형을 결정하고 잘못된 경우 예외 발생)
                - 정적 타입 -> 정적 타입시스템
                    - 추세: 동적타입의 언어를 정적타입의 언어의 특징들을 부여해 시스템의 안정성을 높이자는 것.
                        - 예) 자바스크립트 -> 타입스크립트의 등장, 파이썬의 경우 3.5버전부터 등장한 타입어노테이션
                - 정적 타입시스템의 필요성
                    - 가독성을 높이고 타입에 대한 에러를 미리 방지할 수 있음.
                        - 명시적으로 타입을 파악할 수 있음.
                        - 값들에 대한 대처를 ‘미리’할 수 있음.
                        - 개발자의 잔실수를 막아줌.
        - 데이터 바인딩
            - 화면에 보이는 데이터와 브라우저 메모리상의 데이터가 일치하게 만드는 것
            - 양방향 바인딩(Two-way binding)
                - 뷰에서 이벤트가 발생했을 때, 바로 반영됨
            - 단방향 바인딩(One-way binding)
                - 뷰에서 이벤트가 발생했을 때, 따로 처리해줘야 함.